'use strict';

var util = require('util');
var path = require('path');
var fs = require('fs');
var SQLite = require('sqlite3').verbose();
var Bot = require('slackbots');

//standard strings used for user commands
var help = 'help';
var scoreBoard = 'scoreboard';
var resolved = 'resolved';
var proposed = 'proposed';
var accepted = 'accepted';
var decline = 'decline';
var accept = 'accept';
var cancel = 'cancel';
var anyone = 'anyone';
var firstPlace = ':fire:';
var topThirdEmoji = [':thumbsup:',':sunglasses:',':smirk:',':100:',':four_leaf_clover:',':unicorn_face:'];
var middleThirdEmoji = [':eggplant:',':neutral_face:',':no_mouth:',':face_with_rolling_eyes:',':soon:',':camel:']
var bottomThirdEmoji = [':thinking_face:',':rage:',':sob:',':japanese_goblin:',':thumbsdown:',':arrow_lower_right:',':snake:',':weary:']
var lastPlace = ':poop:';

/**
 * To do list to improve features and code:
 * acceptBet needs to check again that both users can afford the bet before proceeding. A user can currently overdraw their committed points to below 0 (done)
 * Refactor semi-redundant code by developing async methods to return needed values (such as getBetById, getUserById, getUserByName)
 * Refactor admin commands to be formatted more similarly to user commands. Ideally they would be more like natural language.
 * Add optional paramter to listbets command for user to specify the number of bets they wish to show (current default = 20)
 * Allow user to propose to anyone that will accept, and they can respond with "I accept" to confirm last bet (done)
 * trim colons for names that include @signs (done!)
 * Add function to return userId sql search query based on message sender
 * Add logic to handle different odds for bets
 * Enhance the range of automated snarky responses if non-admins make admin requests
 */


/**
 * Constructor function. It accepts a settings object which should contain the following keys:
 *      token : the API token of the bot (mandatory)
 *      name : the name of the bot (will default to "betbot")
 *      dbPath : the path to access the database (will default to "data/betbot.db")
 *      admin : the slack name of the user with admin rights
 *
 * @param {object} settings
 * @constructor
 *
 * @author David Hultengren <david.hultengren@gmail.com>
 */
var BetBot = function Constructor(settings) {
    this.settings = settings;
    this.settings.name = this.settings.name || 'betbot';
    this.dbPath = settings.dbPath || path.resolve(__dirname, '..', 'data', 'betbot.db');
	this.settings.adminId = this.settings.adminId;
	
    this.user = null;
    this.db = null;
};

// inherits methods and properties from the Bot constructor
util.inherits(BetBot, Bot);

/**
 * Run the bot
 * @public
 */
BetBot.prototype.run = function () {
    BetBot.super_.call(this, this.settings);

    this.on('start', this._onStart);
    this.on('message', this._onMessage);
};

/**
 * On Start callback, called when the bot connects to the Slack server and access the channel
 * @private
 */
BetBot.prototype._onStart = function () {
    this._loadBotUser();
    this._connectDb();
};

/**
 * Loads the user object representing the bot
 * @private
 */
BetBot.prototype._loadBotUser = function () {
    var self = this;
    this.user = this.users.filter(function (user) {
        return user.name === self.name;
    })[0];
};

/**
 * Open connection to the db
 * Creates a new database at runtime if no database exists
 * @private
 */
BetBot.prototype._connectDb = function () {
    if (!fs.existsSync(this.dbPath)) {
        
		var sqlite3 = require('sqlite3').verbose();

		var outputFile = path.resolve(this.dbPath);
		var newDB = new sqlite3.Database(outputFile);

		// Prepares the database connection in serialized mode
		newDB.serialize();

		// Creates the database structure
		newDB.run('CREATE TABLE IF NOT EXISTS userPoints (id TEXT PRIMARY KEY, name TEXT, availablePoints INTEGER DEFAULT 0, committedPoints INTEGER DEFAULT 0)');
		newDB.run('CREATE TABLE IF NOT EXISTS bets (id INTEGER PRIMARY KEY, proposer TEXT, proposee TEXT, terms TEXT, amount INTEGER, odds TEXT, state TEXT)');
		newDB.close();
    }

    this.db = new SQLite.Database(this.dbPath);
};


/**
 * On message callback, called when a message (of any type) is detected with the real time messaging API
 * @param {object} message
 * @private
 */
BetBot.prototype._onMessage = function (message) {
	
	try {
		//check to see if message meets basic critera of being a chat message within the channel betbot is part of
		//do not attempt to respond to messages generated by betbot, which could introduce infinite loops
		//if basic criteria are met, process message based on format
		if (this._isChatMessage(message) &&
			this._isChannelConversation(message) &&
			!this._isFromBetBot(message))
		{   				
			if (this._isHelpRequest(message))
			{
				this._showHelp(message);
			}
			else if (this._isIdRequest(message))
			{
				this._getUserId(message);
			}
			else if (this._isScoreBoardRequest(message))
			{
				this._showScoreboard(message);
			}
			else if (this._isListBetsRequest(message))
			{
				this._listBets(message);
			}
			else if (this._isBetRequest(message))
			{
				this._proposeBet(message);
			}
			else if (this._isDeclineRequest(message))
			{
				this._declineBet(message);
			}
			else if (this._isCancelRequest(message))
			{
				this._cancelBet(message);
			}
			else if (this._isAcceptRequest(message))
			{
				this._acceptBet(message);
			}
			else if (this._isAdjudicateRequest(message))
			{
				this._adjudicateBet(message);
			}
			else if (this._isCreateUsersRequest(message))
			{
				this._createUsers(message);
			}
			else if (this._isDeleteRequest(message))
			{
				this._deleteUser(message);
			}
			else if (this._isAssignPointsRequest(message))
			{
				this._assignPoints(message);
			}
			else if (this._isAssignAllPointsRequest(message))
			{
				this._assignAllPoints(message);
			}
		} 
	} catch (err){
		console.error('ERROR:', err);
	}
};

//THIS SECTION CONTAINS FUNCTIONS FOR ALL USERS

/**
 * Replies to scoreboard request with data
 * @param {object} originalMessage
 * @private
 */
BetBot.prototype._showScoreboard = function (originalMessage) {
    var self = this;
	
	//get all user points and format in a table, and respond with a single message
    self.db.all('SELECT * FROM userPoints ORDER BY availablePoints DESC', function (err, rows) {
        if (err) {
            return console.error('DATABASE ERROR:', err);
        }
		
		var scoreBoard = 'Username: Available Points (Committed Points)\n';
		
		var counter = 1;
		var numRows = rows.length;
		
		rows.forEach(function (row) {
			var name = row.name;
			
			var nameLength = name.length;
			
			var firstNamePart = name.substring(0, nameLength - 1);
			var secondNamePart = name.substring(nameLength - 1, nameLength);
			var emoji = self._getEmoji(counter, numRows, originalMessage);
			
			scoreBoard += firstNamePart + '.' + secondNamePart + ': ' + row.availablePoints + ' (' + row.committedPoints + ')\t' + emoji + '\n' ;
			
			counter++;
		});
		
        self._respondInChannel(originalMessage, scoreBoard);
    });
};

/**
 * Allows either member of a bet to adjudicate bet
 * @param {object} originalMessage
 * @private
 */
BetBot.prototype._adjudicateBet = function (originalMessage) {
	var self = this;
	
	//messages for adjuicate bet are of format:
	//I won bet [betid]
	var messageArr = originalMessage.text.split(" ");	
	
	//first validate user input
	//check for minimum required paramter length
	if (messageArr.length !== 4) {
		self._respondInChannel(originalMessage, "Could not parse adjudicate message, please make sure it is formatted as 'I won bet [betid]'");
	}
	else {//check if betId is valid
	
		var betId = messageArr[3];
		var betValidation = "SELECT * FROM bets WHERE id = " + betId + " AND state = '" + accepted + "' LIMIT 1";
		
		self.db.get(betValidation, function (err, betRecord) {
			if (!betRecord) {
				self._respondInChannel(originalMessage, "Couldn't find an active bet with the id " + betId + " make sure you got the right one.")
			}
			else {//get message sender name
				var messageSenderId = originalMessage.user;
				var getMessageSenderName = "SELECT name FROM userPoints WHERE id = '" + messageSenderId + "' LIMIT 1";
				
				self.db.get(getMessageSenderName, function (err, record) {
					var messageSenderName = record.name;
					
					if (messageSenderName !== betRecord.proposer && messageSenderName !== betRecord.proposee) {
						self._respondInChannel(originalMessage, "You can't adjudicate bets you're not involved in. Dingus.")
					}
					else {//compile bet details and settle bet
						
						var betAmount = betRecord.amount;
						
						var loserName = "";
						
						//the loser of the bet is whoever is involved in it, but did not send the message saying they won the bet
						if (messageSenderName === betRecord.proposer) {
							loserName = betRecord.proposee;
						}
						else {
							loserName = betRecord.proposer;
						}
						
						//compile list of points for each user to use when updating user points
						var allUserAvailablePoints = {};
						var allUserCommittedPoints = {};
						
						self.db.all('SELECT * FROM userPoints ORDER BY availablePoints DESC', function (err, rows) {
							if (err) {
								return console.error('DATABASE ERROR:', err);
							}
							
							rows.forEach(function (row) {
								allUserAvailablePoints[row.name] = row.availablePoints;
								allUserCommittedPoints[row.name] = row.committedPoints;
							});
							
							//update points in scoreboard table to adjust committed points for winner
							var updateWinnerPointsStatement = "UPDATE userPoints SET availablePoints = " + (allUserAvailablePoints[messageSenderName] + (2*betAmount)) + 
								", committedPoints = " + (allUserCommittedPoints[messageSenderName] - betAmount) + " WHERE name = '" + messageSenderName + "'";
								
							self.db.run(updateWinnerPointsStatement, function (err, result) {
								if (err) {
									self._respondInChannel(originalMessage, "There was an error adjudicating the bet. In the part where it updates scores for the winner.");
								}
								else {//update points in scoreboard for loser

									var updateLoserPointsStatement = "UPDATE userPoints SET committedPoints = " + (allUserCommittedPoints[loserName] - betAmount) + " WHERE name = '" + loserName + "'";
									
									self.db.run(updateLoserPointsStatement, function (err, result) {
										if (err) {
											self._respondInChannel(originalMessage, "There was an error adjudicating the bet. In the part where it updates scores for the loser.");
										}
										else {//send message indicating completion and update bet status
											self._respondInChannel(originalMessage, "Dear " + messageSenderName + ", congrats on winning your bet! Dear " 
											+ loserName + ", your bet was bad and you should feel bad." );
											
											//update the bet state to resolved once all other steps are completed
											var updateBetState = "UPDATE bets set state = '" + resolved + "' WHERE id = " + betRecord.id;
											
											self.db.run(updateBetState, function (err, result) {});
												
										}
									});
								}
							});
						});
					}
				});
			}
		});
	}
};


/**
 * Replies to a user's id request with their unique userId
 * This is needed in our database to determine the username of anyone who sends a message, as only UserId is exposed via the API
 * @param {object} originalMessage
 * @private
 */
BetBot.prototype._getUserId = function (originalMessage) {
	this._respondInChannel(originalMessage, "Your userId is " + originalMessage.user);
};

/**
 * Shows all bets based on filters
 * @param {object} originalMessage
 * @private
 */
BetBot.prototype._listBets = function (originalMessage) {
    var self = this;
	
	//listbets is formatted like listbets [optional:-mine] [optional:-[state] ('a' for accepted, 'p' for proposed' and 'r' for resolved");	
	var whereAdded = false;
	var messageText = originalMessage.text.toLowerCase(); 
	var baseQuery = "SELECT * FROM bets";
	
	//if state flag is included add it to the baseQuery
	if (messageText.indexOf("-a") > 0 || messageText.indexOf("-p") > 0 || messageText.indexOf("-r") > 0) {
		whereAdded = true;
		
		var stateName = accepted;
		
		if (messageText.indexOf("-p") > 0) {
			stateName = proposed;
		}
		else if (messageText.indexOf("-r") > 0) {
			stateName = resolved;
		}
		
		baseQuery += " WHERE state = '" + stateName + "'";
	}
	
	//if -mine flag included filter only on user who sent message
	if (messageText.indexOf('-mine') > 0) {
	
		var proposerID = originalMessage.user;
		var getProposerNameStatement = "SELECT name FROM userPoints WHERE id = '" + proposerID + "' LIMIT 1";
		
		self.db.get(getProposerNameStatement, function (err, record) {
			if (err) {
				return console.error('DATABASE ERROR:', err);
			}

			//user not found, seend error message
			if (!record) {
				self._respondInChannel(originalMessage, "You can't list your own bets until you've been added as a user. Contanct your betbot admin for help.");
			}
			else {
				var userName = record.name;
				
				if (!whereAdded) {
					baseQuery += " WHERE ";
				}
				else {
					baseQuery += " AND ";
				}
				
				baseQuery += "(proposer = '" + userName + "' OR proposee = '" + userName + "') ORDER BY id DESC LIMIT 20";
				
				self.db.all(baseQuery, function (err, rows) {
					if (err) {
						return console.error('DATABASE ERROR:', err);
					}
					
					var listBets = self._formatListBets(rows);
					
					self._respondInChannel(originalMessage, listBets);
				});					
			}
		});		
	}
	else {//mine flag not included run query on all users
		baseQuery += " ORDER BY id DESC LIMIT 20";
		
		self.db.all(baseQuery, function (err, rows) {
			if (err) {
				return console.error('DATABASE ERROR:', err);
			}
			
			var listBets = self._formatListBets(rows);
			
			self._respondInChannel(originalMessage, listBets);
		});
	}
};

/**
 * Propose a bet to another user
 * @param {object} originalMessage
 * @private
 */
BetBot.prototype._proposeBet = function (originalMessage) {
    var self = this;
	
	if (originalMessage.text.length > 200) {
		self._respondInChannel(originalMessage, "That bet is obscenely long, make it shorter.");
	}
	else {
		//messages for propose bet are of format:
		//I bet [user] [integer] [optional word points] [optional word that] [bet terms]
		var messageArr = originalMessage.text.split(" ");	
		
		//check if username bet is proposed to exists
		var proposeeValidation = self._getUserSqlQuery(messageArr[2], originalMessage);
		
		var isAnyoneBet = messageArr[2].toLowerCase() === anyone;
		
		self.db.get(proposeeValidation, function (err, result) {
			if (!result && !isAnyoneBet) {
				self._respondInChannel(originalMessage, "I couldn't find the user you're trying to bet with, make sure you spelled it right");
			}
			else {//check if bet amount is actually a number
			
				var proposeeName = '';
				
				if (isAnyoneBet) {
					proposeeName = anyone;
				} else {
					proposeeName = result.name;
				}
				
				var betAmount = parseInt(messageArr[3]);
				
				if (!self._isInteger(betAmount)) {
					self._respondInChannel(originalMessage, "I couldn't parse the bet amount you submitted, make sure it's an integer.");
				}
				else if (betAmount < 1) {
					self._respondInChannel(originalMessage, "The bet amount must be an integer greater than 0.");
				}
				else {//attempt to propose bet
				
					//if user omits optional words "points" and "that", the terms start at the end of the number of points the user bet
					var termsStartIndex = originalMessage.text.indexOf(messageArr[3]) + messageArr[3].length + 1;
					
					//search for optional words "points" and "that" the user might submit to make query more language friendly
					//do not include them in the value for 'terms' stored in the database
					var pointsIndex = originalMessage.text.toLowerCase().indexOf('points') + 6;
					var thatIndex = originalMessage.text.toLowerCase().indexOf('that') + 4;
					
					//the real start index of the terms appears after any optional words are included
					var actualStartIndex = Math.max(termsStartIndex, pointsIndex, thatIndex);
					
					//escape characters in string that cause sql errors and trim extra whitespace
					var betTerms = self._escapeSqlString(originalMessage.text.substring(actualStartIndex, originalMessage.text.length)).trim();
											
					var proposerID = originalMessage.user;
					var getProposerNameStatement = "SELECT name FROM userPoints WHERE id = '" + proposerID + "' LIMIT 1";
					
					self.db.get(getProposerNameStatement, function (err, record) {
						if (err) {
							self._respondInChannel(originalMessage, "error getting your name");
							return console.error('DATABASE ERROR:', err);
						}

						//user not found, seend error message
						if (!record) {
							self._respondInChannel(originalMessage, "You can't propose bets until you've been added as a user. Contanct your betbot admin for help.");
						}
						else {//user exists, check if there is already an awaiting proposed bet with the proposee
							var proposerName = record["name"];
							var getExistingBetsStatement = "SELECT * FROM bets WHERE proposer = '" + proposerName + "' AND proposee = '" + proposeeName 
								+ "' AND state = '" + proposed + "' LIMIT 1";
					
							self.db.get(getExistingBetsStatement, function (err, record) {
								if (record) {
									self._respondInChannel(originalMessage, "You can't propose a new bet to that user until they accept or decline the previous bet or you cancel it.");
								}
								else {
									
									//if no current bet is found, check to make sure both users can afford bet
									var playerScores = {};
									var proposerAvailablePoints = 0;
									var proposerCommittedPoints = 0;
									self.db.all('SELECT * FROM userPoints ORDER BY availablePoints DESC', function (err, rows) {
										if (err) {
											return console.error('DATABASE ERROR:', err);
										}
										
										rows.forEach(function (row) {
											playerScores[row.name] = row.availablePoints;
											if (row.name === proposerName) {
												proposerAvailablePoints = row.availablePoints;
												proposerCommittedPoints = row.committedPoints;
											}
										});
										
										if (playerScores[proposerName] >= betAmount && (playerScores[proposeeName] >= betAmount || isAnyoneBet)) {
											//all tests passed, insert bet into database in state proposed
											var insertStatement = "INSERT INTO bets (proposer, proposee, terms, amount, odds, state) VALUES ('" 
												+ proposerName + "','" + proposeeName + "','" + betTerms + "'," + betAmount + ",'1:1','" + proposed + "')";
											
											self.db.run(insertStatement, function (err, result) {
												if (err) {
													return console.error('DATABASE ERROR:', err);
												}
												else
												{												
													//update points in scoreboard table to move adjust committed points for proposer only
													//proposee will be updated if they accept
													var updateCommitedPointsStatment = "UPDATE userPoints SET availablePoints = " + (proposerAvailablePoints - betAmount) + 
														", committedPoints = " + (proposerCommittedPoints + betAmount) + " WHERE name = '" + proposerName + "'";
														
													self.db.run(updateCommitedPointsStatment, function (err, result) {
														if (err) {
															self._respondInChannel(originalMessage, "There was an error proposing the bet. In the part where it updates scores.");
														}
														else {
															self._respondInChannel(originalMessage, "You've successfully bet " + proposeeName + " " + betAmount 
															+ " points that " + betTerms);	
														}
													});
												}
											});
										}
										else {//inform user that the bet terms are too rich
											self._respondInChannel(originalMessage, "One or more of you can't afford this bet, check available funds using the scoreboard command.");
										}
									});
								}
							});
						}
					});
				}
			}
		});
	}
};


/**
 * Accept a bet proposed another user
 * @param {object} originalMessage
 * @private
 */
BetBot.prototype._acceptBet = function (originalMessage) {
	var self = this;
	
	//messages for accept bet are of format:
	//[userName who proposed bet] accept
	var messageArr = originalMessage.text.split(" ");	
	
	//first validate user input
	//check for minimum required paramter length
	if (messageArr.length !== 2) {
		self._respondInChannel(originalMessage, "I could not parse accept message, please make sure it is formatted as '[username] accept'");
	}
	else {//check if passed userName exists
		var proposerValidation = self._getUserSqlQuery(messageArr[0], originalMessage);
		
		self.db.get(proposerValidation, function (err, result) {
			if (!result) {
				self._respondInChannel(originalMessage, "Couldn't find a user with the name " + messageArr[0] + " make sure it is spelled correctly (case sensitive).")
			}
			else {
				var proposerName = result.name;
				var proposeeID = originalMessage.user;
				var getProposeeNameStatement = "SELECT name FROM userPoints WHERE id = '" + proposeeID + "' LIMIT 1";
				
				self.db.get(getProposeeNameStatement, function (err, record) {
					if (err) {
						return console.error('DATABASE ERROR:', err);
					}

					//user not found, send error message
					if (!record) {
						self._respondInChannel(originalMessage, "You can't accept bets until you've been added as a user. Contanct your betbot admin for help.");
					}
					else {//user exists, check if there is already an awaiting proposed bet with the proposee
						var proposeeName = record.name;
						var getExistingBetsStatement = "SELECT * FROM bets WHERE proposer = '" + proposerName + "' AND (proposee = '" + proposeeName + "' OR proposee = '" + anyone + "')"
							+ " AND state = '" + proposed + "' LIMIT 1";
				
						self.db.get(getExistingBetsStatement, function (err, record) {
							if (err) {
								return console.error('DATABASE ERROR:', err);
							}

							if (!record) {
								self._respondInChannel(originalMessage, proposerName + " hasn't proposed a bet to you, dummy.");
							}
							else {
								//if bet was made to anyone get the user who accepts it to store with bet info
								if (record.proposee === anyone) {
									var proposeeID = originalMessage.user;
									var getProposeeNameStatement = "SELECT name FROM userPoints WHERE id = '" + proposeeID + "' LIMIT 1";
									
									self.db.get(getProposeeNameStatement, function (err, proposeeRecord) {
										if (err) {
											return console.error('DATABASE ERROR:', err);
										}
										else {
											proposeeName = proposeeRecord.name;
											
											self._updateBetOnAccept(originalMessage, record, proposeeName)
											
										}	
									});
								}
								else {
									self._updateBetOnAccept(originalMessage, record, proposeeName);
								}
							}
						});
					}
				});
			}
		});
	}
};

/**
 * Decline a bet proposed another user
 * @param {object} originalMessage
 * @private
 */
BetBot.prototype._declineBet = function (originalMessage) {
    var self = this;
	
	//messages for decline bet are of format:
	//betbot [userName who proposed bet] decline
	var messageArr = originalMessage.text.split(" ");	
	
	//check for required paramter length
	if (messageArr.length !== 2) {
		self._respondInChannel(originalMessage, "Could not parse decline message, please make sure it is formatted as '[username] decline'");
	}
	else {//check if passed userName exists
		var proposerValidation = self._getUserSqlQuery(messageArr[0], originalMessage);
		
		self.db.get(proposerValidation, function (err, result) {
			if (!result) {
				self._respondInChannel(originalMessage, "Couldn't find a user with the name " + proposerName + " make sure it is spelled correctly (case sensitive).")
			}
			else {
				var proposerName = result.name;
				var proposeeID = originalMessage.user;
				var getProposeeNameStatement = "SELECT name FROM userPoints WHERE id = '" + proposeeID + "' LIMIT 1";
				
				self.db.get(getProposeeNameStatement, function (err, record) {
					if (err) {
						return console.error('DATABASE ERROR:', err);
					}

					//user not found, send error message
					if (!record) {
						self._respondInChannel(originalMessage, "You can't decline bets until you've been added as a user. Contanct your betbot admin for help.");
					}
					else {//user exists, check if there is already an awaiting proposed bet with the proposee
						var proposeeName = record.name;
						var getExistingBetsStatement = "SELECT * FROM bets WHERE proposer = '" + proposerName + "' AND proposee = '" + proposeeName 
							+ "' AND state = '" + proposed + "' LIMIT 1";
				
						self.db.get(getExistingBetsStatement, function (err, record) {
							if (err) {
								return console.error('DATABASE ERROR:', err);
							}

							if (!record) {
								self._respondInChannel(originalMessage, proposerName + " hasn't proposed a bet to you, dummy.");
							}
							else {//delete bet from table
								var amount = record.amount;
								var deleteStatment = "DELETE FROM bets WHERE id = " + record.id;
								
								self.db.run(deleteStatment, function (err, result) {
									if (err) {
										return console.error('DATABASE ERROR:', err);
									}
									else
									{
										var proposerAvailablePoints = 0;
										var proposerCommittedPoints = 0;
										self.db.all('SELECT * FROM userPoints ORDER BY availablePoints DESC', function (err, rows) {
											if (err) {
												return console.error('DATABASE ERROR:', err);
											}
											
											rows.forEach(function (row) {
												if (row.name === proposerName) {
													proposerAvailablePoints = row.availablePoints;
													proposerCommittedPoints = row.committedPoints;
												}
											});
											
											//update points in scoreboard table to adjust committed points for proposer only
											var updateCommitedPointsStatment = "UPDATE userPoints SET availablePoints = " + (proposerAvailablePoints + amount) + 
												", committedPoints = " + (proposerCommittedPoints - amount) + " WHERE name = '" + proposerName + "'";
												
											self.db.run(updateCommitedPointsStatment, function (err, result) {
												if (err) {
													self._respondInChannel(originalMessage, "There was an error declining the bet. In the part where it updates scores.");
												}
												else {
													self._respondInChannel(originalMessage, "You've successfully declined the bet proposed to you by " + proposerName);
												}
											});
											
										});
									}
								});
							}
						});
					}
				});
			}
		});
	}    
};

/**
 * Cancel a bet you've proposed as long as it hasn't been accepted
 * @param {object} originalMessage
 * @private
 */
BetBot.prototype._cancelBet = function (originalMessage) {
    var self = this;
	
	//messages for cancel bet are of format:
	//@[username to whom you proposed] cancel
	var messageArr = originalMessage.text.split(" ");	
	
	//check for required paramter length
	if (messageArr.length !== 2) {
		self._respondInChannel(originalMessage, "Could not parse cancel message, please make sure it is formatted as '[username] cancel'");
	}
	else {//check if passed userName exists
		var proposeeName = messageArr[0];
		var proposeeValidation = self._getUserSqlQuery(proposeeName, originalMessage);
		
		var isAnyoneBet = proposeeName.toLowerCase() === anyone;
		
		self.db.get(proposeeValidation, function (err, result) {
			if (!result && !isAnyoneBet) {
				self._respondInChannel(originalMessage, "Couldn't find a user with the name " + proposeeName + " make sure it is spelled correctly (case sensitive).")
			}
			else {
				proposeeName = '';
				
				if (isAnyoneBet) {
					proposeeName = anyone;
				}
				else {
					proposeeName = result.name;
				}
				
				var proposerID = originalMessage.user;
				var getProposerNameStatement = "SELECT name FROM userPoints WHERE id = '" + proposerID + "' LIMIT 1";
				
				self.db.get(getProposerNameStatement, function (err, record) {
					if (err) {
						return console.error('DATABASE ERROR:', err);
					}

					//user not found, send error message
					if (!record) {
						self._respondInChannel(originalMessage, "You can't cancel bets until you've been added as a user. Contanct your betbot admin for help.");
					}
					else {//user exists, check if there is already an awaiting proposed bet with the proposee
						var proposerName = record.name;
						var getExistingBetsStatement = "SELECT * FROM bets WHERE proposer = '" + proposerName + "' AND proposee = '" + proposeeName 
							+ "' AND state = '" + proposed + "' LIMIT 1";
				
						self.db.get(getExistingBetsStatement, function (err, record) {
							if (err) {
								return console.error('DATABASE ERROR:', err);
							}

							if (!record) {
								self._respondInChannel(originalMessage, "You haven't proposed a bet to " + proposeeName + " you dummy.");
							}
							else {//delete bet from table
								var amount = record.amount;
								var deleteStatment = "DELETE FROM bets WHERE id = " + record.id;
								
								self.db.run(deleteStatment, function (err, result) {
									if (err) {
										return console.error('DATABASE ERROR:', err);
									}
									else
									{
										var proposerAvailablePoints = 0;
										var proposerCommittedPoints = 0;
										self.db.all('SELECT * FROM userPoints ORDER BY availablePoints DESC', function (err, rows) {
											if (err) {
												return console.error('DATABASE ERROR:', err);
											}
											
											rows.forEach(function (row) {
												if (row.name === proposerName) {
													proposerAvailablePoints = row.availablePoints;
													proposerCommittedPoints = row.committedPoints;
												}
											});
											
											//update points in scoreboard table to adjust committed points for proposer only (only their points were previously set)
											var updateCommitedPointsStatment = "UPDATE userPoints SET availablePoints = " + (proposerAvailablePoints + amount) + 
												", committedPoints = " + (proposerCommittedPoints - amount) + " WHERE name = '" + proposerName + "'";
												
											self.db.run(updateCommitedPointsStatment, function (err, result) {
												if (err) {
													self._respondInChannel(originalMessage, "There was an error canceling the bet. In the part where it updates scores.");
												}
												else {
													self._respondInChannel(originalMessage, "You've successfully canceld the bet you proposed to " + proposeeName);
												}
											});
											
										});
									}
								});
							}
						});
					}
				});
			}
		});
	}    
};

/**
 * Replies to scoreboard request with data
 * @param {object} originalMessage
 * @private
 */
BetBot.prototype._showHelp = function (originalMessage) {
	var helpMessage = "```Try any of the following commands\n";
	helpMessage += "'scoreboard' to see the current scoreboard.\n";
	helpMessage += "'listbets [optional flag:-mine] [optional flag:-[state]' to list bets. State can be 'p' for proposed', 'a' for accepted, and 'r' for resolved\n";
	helpMessage += "To propose a bet, format your message like this: 'I #bet [username] [x points] that [terms of bet]'\n";
	helpMessage += "'[userName] cancel' to cancel a pending bet you proposed to that user.\n";
	helpMessage += "'[userName] accept' to accept a bet from that user.\n";
	helpMessage += "'[userName] decline' to decline a bet from that user.\n"
	helpMessage += "To resolve a bet, format your message like this 'I won bet [betId]'. BetId can be found by running listbets.";
	
	if (this._isFromAdmin(originalMessage)) {
		helpMessage += "\nTo create a new user use 'betbot cu [username]' [userid] do not change casing.";
		helpMessage += "\nTo delete a user 'betbot delete [username]'"
		helpMessage += "\nTo adjust a users points 'betbot assign [user] [points] [optional:-c]'";
		helpMessage += "\nTo assign everyone points 'betbot assignall [points]'";
	}
	
	helpMessage += "```";
	
	this._respondInChannel(originalMessage, helpMessage);	
};

//THESE ARE ADMIN ONLY FUNCTIONS USED TO CREATE/DELETE USERS AND ADJUST SCORES IF NEEDED

/**
 * assign points to a user, admin only
 * @param {object} originalMessage
 * @private
 */
BetBot.prototype._assignPoints = function (originalMessage) {
	var self = this;
	
	if (self._isFromAdmin(originalMessage)) {
		
		//messages for assignPoints are of format:
		//betbot assign [user] [points] [optional:-c]
		//optional flag -c changes committed points value, default is available points
		var messageArr = originalMessage.text.split(" ");	
		
		//first validate user input
		//check for minimum required paramter length
		if (messageArr.length < 4) {
			self._respondInChannel(originalMessage, "could not parse assign message, please make sure it is formatted betbot assign [user] [points] [optional:-c]");
		}
		else {//check if passed userName exists
			var userName = messageArr[2];
			var userValidation = "SELECT * FROM userPoints WHERE name = '" + userName + "' LIMIT 1";
			
			self.db.get(userValidation, function (err, result) {
				if (!result) {
					self._respondInChannel(originalMessage, "Could find a user with the name " + proposerName + " make sure it is spelled correctly (case sensitive).")
				}
				else {
					var assignAmount = parseInt(messageArr[3]);
					var columnToUpdate = 'availablePoints';
					var currentPoints = result.availablePoints;
					
					if (messageArr.length === 5 && messageArr[4] === '-c') {
						columnToUpdate = 'committedPoints';
						currentPoints = result.committedPoints;
					}
						
					var updateStatement = "UPDATE userPoints SET " + columnToUpdate + " = " + (currentPoints + assignAmount) + " WHERE name = '" + userName + "'";
					
					self.db.run(updateStatement, function (err, updateResult) {
						if (err) {
							self._respondInChannel(originalMessage, "There was an error updating the user score.");
						}
						else
						{
							self._respondInChannel(originalMessage, "User score updated successfully from " + currentPoints + " to " + (currentPoints + assignAmount));				
						}
					});
				}
			});
		}
	} else {
		self._returnSnarkyResponse(originalMessage);
	}    
};

/**
 * assign points to all user, admin only
 * @param {object} originalMessage
 * @private
 */
BetBot.prototype._assignAllPoints = function (originalMessage) {
	var self = this;
	
	if (self._isFromAdmin(originalMessage)) {
		
		//messages for assignAll are of format:
		//betbot assignall [points]
		//optional flag -c changes committed points value, default is available points
		var messageArr = originalMessage.text.split(" ");	
		
		//first validate user input
		//check for minimum required paramter length
		if (messageArr.length < 3) {
			self._respondInChannel(originalMessage, "could not parse assignall message, please make sure it is formatted betbot assignall [points]");
		}
		else {
			var assignAmount = parseInt(messageArr[2]);
			
			self.db.all('SELECT * FROM userPoints ORDER BY availablePoints DESC', function (err, rows) {
				if (err) {
					return console.error('DATABASE ERROR:', err);
				}
				
				var errors = "";
				
				rows.forEach(function (row) {
					var updateStatement = "UPDATE userPoints SET availablePoints = " + (row.availablePoints + assignAmount) + " WHERE name = '" + row.name + "'";
					
					self.db.run(updateStatement, function (err, updateResult) {
						if (err) {
							errors += "There was an error updating the user with name " + row.name + "\r\n";
						}
						
					});
				});
				
				var finalMessage = "";
				
				if (errors === "") {
					finalMessage = "All users updated successfully."
				}
				else {
					finalMessage = errors;
				}
				
				self._respondInChannel(originalMessage, finalMessage);
			});
		}
				
	} else {
		self._returnSnarkyResponse(originalMessage);
	}    
};

/**
 * Creates new users
 * @param {object} originalMessage
 * @private
 */
BetBot.prototype._createUsers = function (originalMessage) {
    var self = this;
	
	if (self._isFromAdmin(originalMessage)) {
			
		var messageArr = originalMessage.text.split(" ");	
		
		//message is formatted as betbot cu [username] [userId]
		if (messageArr.length < 4)
		{
			self._respondInChannel(originalMessage, 'You must format your user creation message as betbot cu [username] [userId]');
		}
		else
		{
			var userName = messageArr[2];
			var userId = messageArr[3];
			var selectStatement = "SELECT name FROM userPoints WHERE name = '" + userName + "' LIMIT 1";
			
			self.db.get(selectStatement, function (err, record) {
				if (err) {
					return console.error('DATABASE ERROR:', err);
				}

				//user not found, add to database
				if (!record) {
					var insertStatement = "INSERT INTO userPoints (id, name, availablePoints, committedPoints) VALUES ('" + userId + "','" + userName + "', 50, 0)";
			
					self.db.run(insertStatement, function (err, result) {
					if (err) {
						return console.error('DATABASE ERROR:', err);
					}
					else
					{
						self._respondInChannel(originalMessage, 'user ' + userName + ' successfully created and assigned 50 points');
					}});
				}
				else {//user already exists
					self._respondInChannel(originalMessage, 'user ' + userName + ' already exists in database.');
				}
			});
		
		}
	} else {
		self._returnSnarkyResponse(originalMessage);
	}
};


/**
 * Deletes a user by name, admin only
 * @param {object} originalMessage
 * @private
 */
BetBot.prototype._deleteUser = function (originalMessage) {
    var self = this;
		
	if (self._isFromAdmin(originalMessage)) {
			
		var messageArr = originalMessage.text.split(" ");	
		
		if (messageArr.length === 2)
		{
			self._respondInChannel(originalMessage, 'you must specify the name of the user to delete.');
		}
		else
		{
			var userName = messageArr[2];
			var selectStatement = "SELECT name FROM userPoints WHERE name = '" + userName + "' LIMIT 1";
			
			self.db.get(selectStatement, function (err, record) {
				if (err) {
					return console.error('DATABASE ERROR:', err);
				}

				//user not found, cannot delete
				if (!record) {
					self._respondInChannel(originalMessage, 'user ' + userName + ' was not found in the database.');
				}
				else {//user exsits
					var deleteStatment = "DELETE FROM userPoints WHERE name = '" + userName + "'";
					self.db.run(deleteStatment, function(err) {
						if (err)
						{
							self._respondInChannel(originalMessage, 'There was an error deleting the user.');
						}
						else {
							self._respondInChannel(originalMessage, 'user ' + userName + ' successfully deleted.');
						}
					});
				}
			});
		
		}
	} else {
		self._returnSnarkyResponse(originalMessage);
	}
};


//HELPER FUNCTIONS NOT CALLED DIRECTLY BY USERS

/**
 * Sends a message from betbot in the same channel as originalMessage came rom
 * @param {object} originalMessage
 * @private
 */
BetBot.prototype._respondInChannel = function (originalMessage, responseText) {
    var self = this;
			
	var channel = self._getChannelById(originalMessage.channel);
	self.postMessageToChannel(channel.name, responseText, {as_user: true});

};

/**
 * Replies with snarky response if non-admin makes admin request
 * @param {object} originalMessage
 * @private
 */
BetBot.prototype._returnSnarkyResponse = function (originalMessage) {
    this._respondInChannel(originalMessage, 'ah ah ah, what\'s the magic word?');
};

/**
 * private function returns an emoji to match the standing of the user
 * to make the scoreboard more interesting 
 */
BetBot.prototype._getEmoji = function(counter, numRows, originalMessage)
{
	var thirds = numRows / 3;
	
	if (counter === 1) {
		return firstPlace;
	}
	else if (counter === numRows) {
		return lastPlace;
	}
	else if (counter > thirds * 2) {
		return bottomThirdEmoji[this._getRandomArbitrary(0, bottomThirdEmoji.length - 1)];
	}
	else if (counter > thirds) {
		return middleThirdEmoji[this._getRandomArbitrary(0, middleThirdEmoji.length - 1)];
	}
	else {
		return topThirdEmoji[this._getRandomArbitrary(0 ,topThirdEmoji.length - 1)];
	}
	
}

/**
 * Returns a random number between min (inclusive) and max (exclusive)
 */
BetBot.prototype._getRandomArbitrary = function(min, max) {
    return Math.floor(Math.random() * (max - min+ 1)) + min;
}


/**
 * Util function to check if a given real time message object represents a chat message
 * @param {object} message
 * @returns {boolean}
 * @private
 */
BetBot.prototype._isChatMessage = function (message) {
    return message.type === 'message' && Boolean(message.text);
};

/**
 * Util function to check if a given real time message object is directed to a channel
 * @param {object} message
 * @returns {boolean}
 * @private
 */
BetBot.prototype._isChannelConversation = function (message) {
    return typeof message.channel === 'string' &&
        message.channel[0] === 'C';
};

/**
 * Util function to check if a given real time message is making a scoreboard request
 * @param {object} message
 * @returns {boolean}
 * @private
 */
BetBot.prototype._isScoreBoardRequest = function (message) {
	return message.text.toLowerCase() === scoreBoard;	
};

/**
 * Util function to check if a given real time message is making a request to adjust user points
 * @param {object} message
 * @returns {boolean}
 * @private
 */
BetBot.prototype._isAssignPointsRequest = function (message) {
	var messageArr = message.text.toLowerCase().split(" ");	
	
    return messageArr.length >= 2 && messageArr[1] === 'assign';
};

/**
 * Util function to check if a given real time message is making a request to adjust all user points simultaneously
 * @param {object} message
 * @returns {boolean}
 * @private
 */
BetBot.prototype._isAssignAllPointsRequest = function (message) {
	var messageArr = message.text.toLowerCase().split(" ");	
	
    return messageArr.length >= 2 && messageArr[1] === 'assignall';
};

/**
 * Util function to check if a given real time message is making a list bets request
 * @param {object} message
 * @returns {boolean}
 * @private
 */
BetBot.prototype._isListBetsRequest = function (message) {
	return message.text.toLowerCase().startsWith('listbets');
};


/**
 * Util function to check if a given real time message is making a decline request
 * @param {object} message
 * @returns {boolean}
 * @private
 */
BetBot.prototype._isDeclineRequest = function (message) {
	var messageArr = message.text.toLowerCase().split(" ");	
	
    return messageArr.length === 2 && messageArr[1] === decline;
};

/**
 * Util function to check if a given real time message is making an accept request
 * @param {object} message
 * @returns {boolean}
 * @private
 */
BetBot.prototype._isAcceptRequest = function (message) {
	var messageArr = message.text.toLowerCase().split(" ");	
	
    return messageArr.length === 2 && messageArr[1] === accept;
};

/**
 * Util function to check if a given real time message is making a cancel request
 * @param {object} message
 * @returns {boolean}
 * @private
 */
BetBot.prototype._isCancelRequest = function (message) {
	var messageArr = message.text.toLowerCase().split(" ");	
	
    return messageArr.length === 2 && messageArr[1] === cancel;
};

/**
 * Util function to check if a given real time message is asking for a user's id
 * @param {object} message
 * @returns {boolean}
 * @private
 */
BetBot.prototype._isIdRequest = function (message) {
	var messageArr = message.text.toLowerCase().split(" ");	
	
    return messageArr.length === 2 && messageArr[1] === 'id';
};

/**
 * Util function to check if a given real time message is making a bet proposal request
 * @param {object} message
 * @returns {boolean}
 * @private
 */
BetBot.prototype._isBetRequest = function (message) {
	var messageText = message.text.toLowerCase();	
	
    return messageText.startsWith('i #bet');
};

/**
 * Util function to check if a given real time message is making a delete user request
 * @param {object} message
 * @returns {boolean}
 * @private
 */
BetBot.prototype._isDeleteRequest = function (message) {
	var messageArr = message.text.toLowerCase().split(" ");	
    return messageArr.length >= 2 && (messageArr[1] === 'delete');
};

/**
 * Util function to check if a given real time message is making a debug request
 * @param {object} message
 * @returns {boolean}
 * @private
 */
BetBot.prototype._isFromAdmin = function (message) {
    return message.user === this.settings.adminId ;
};


/**
 * Util function to check if a given real time message is asking for help
 * @param {object} message
 * @returns {boolean}
 * @private
 */
BetBot.prototype._isHelpRequest = function (message) {
	var messageArr = message.text.toLowerCase().split(" ");
    return messageArr.length === 2 && (messageArr[1] === help || messageArr[1] === 'h' || messageArr[1] === '?')
		&& messageArr[0].toLowerCase() === 'betbot';
};

/**
 * Util function to check if a given real time message is creating users. This is only available to the admin
 * @param {object} message
 * @returns {boolean}
 * @private
 */
BetBot.prototype._isCreateUsersRequest = function (message) {
	var messageArr = message.text.toLowerCase().split(" ");
    return (messageArr.length >= 2 && messageArr[1] === 'cu');
};

/**
 * Util function to check if a given real time message is attempting to adjudicate a bet
 * @param {object} message
 * @returns {boolean}
 * @private
 */
BetBot.prototype._isAdjudicateRequest = function (message) {
	return message.text.toLowerCase().startsWith('i won bet');
};

/**
 * Util function to check if a given real time message has ben sent by the betbot
 * @param {object} message
 * @returns {boolean}
 * @private
 */
BetBot.prototype._isFromBetBot = function (message) {
    return message.user === this.user.id;
};

/**
 * Util function to get the name of a channel given its id
 * @param {string} channelId
 * @returns {Object}
 * @private
 */
BetBot.prototype._getChannelById = function (channelId) {
    return this.channels.filter(function (item) {
        return item.id === channelId;
    })[0];
};

/**
 * Util function to determine if passed parameter is an integer
 * @param {int} value
 * @returns {Object}
 * @private
 */
BetBot.prototype._isInteger = function (value) {
  var x = parseFloat(value);
  return !isNaN(value) && (x | 0) === x;
};

/**
 * Util function to trim the @ sign if included with a username and return a sql query to validate the username
 * @param {string} name
 * @returns {string}
 * @private
 */
BetBot.prototype._getUserSqlQuery = function (name, message) {
	var searchColumn = 'name';
	
	if (name.indexOf('@') > 0) {
		searchColumn = 'id';
	}
	
	if (name.endsWith(':')) {
		name = name.substring(0, name.length - 1);
	}
	
	var trimmedNameOrId = "";
	
	//if you use an @sign slack converts the name to an ID
	if (name.indexOf('@') > 0) {	  
	  trimmedNameOrId = name.substring(2, name.length - 1);
	}	
    else {
		trimmedNameOrId = name;
	}
		
	return "SELECT * FROM userPoints WHERE " + searchColumn + " = '" + trimmedNameOrId + "' LIMIT 1";
};

/**
 * Util function to format the output for listbets command
 * @param {sql rows} rows
 * @returns {string}
 * @private
 */
BetBot.prototype._formatListBets = function (rows) {
	var listBets = '```BetID\tBetTerms\n';

	rows.forEach(function (row) {
		listBets += row.id + '\t' + row.proposer + ' bet ' + row.proposee + ' ' + row.amount + ' points that ' + row.terms 
			+ '. The bet is ' + row.state + '.\n';
	});
	
	listBets += '```';

	return listBets;
};

/**
 * Util function to update bets table once a bet has been accepted
 * @param {betrecord} record {string} proposeeName
 * void
 * @private
 */
BetBot.prototype._updateBetOnAccept = function (originalMessage, record, proposeeName) {
	var self = this;
	
	var amount = record.amount;
	var proposerName = record.proposer;
	
	var updateStatement = "UPDATE bets SET state = '" + accepted + "' WHERE id = " + record.id;
								
	self.db.run(updateStatement, function (err, result) {
		if (err) {
			return console.error('DATABASE ERROR:', err);
		}
		else
		{
			var proposeeAvailablePoints = 0;
			var proposeeCommittedPoints = 0;
			var proposerAvailablePoints = 0;
			self.db.all('SELECT * FROM userPoints ORDER BY availablePoints DESC', function (err, rows) {
				if (err) {
					return console.error('DATABASE ERROR:', err);
				}
				
				rows.forEach(function (row) {
					if (row.name === proposeeName) {
						proposeeAvailablePoints = row.availablePoints;
						proposeeCommittedPoints = row.committedPoints;
					}
					if (row.name === proposerName) {
						proposerAvailablePoints = row.availablePoints;
					}
				});
				
				//double check to make sure person can still afford bet
				if (proposeeAvailablePoints - amount < 0) {
					self._respondInChannel(originalMessage, "You no longer have enough available points to accept this bet, sorry.");
				}
				else if (proposerAvailablePoints - amount < 0) {
					self._respondInChannel(originalMessage, "The person who proposed this bet no longer has enough available points to make this bet, sorry.");
				}												
				else {
					//update points in scoreboard table to adjust committed points for proposee only, proposer has already been updated
					var updateCommitedPointsStatment = "UPDATE userPoints SET availablePoints = " + (proposeeAvailablePoints - amount) + 
						", committedPoints = " + (proposeeCommittedPoints + amount) + " WHERE name = '" + proposeeName + "'";
						
					self.db.run(updateCommitedPointsStatment, function (err, result) {
						if (err) {
							self._respondInChannel(originalMessage, "There was an error accepting the bet. In the part where it updates scores.");
						}
						else {
							self._respondInChannel(originalMessage, "You've successfully accepted the bet proposed to you by " + proposerName);
						}
					});
				}
				
			});
		}
	});
}

/**
 * Util function to format a string for sql database insertion
 * @param {int} value
 * @returns {Object}
 * @private
 */
BetBot.prototype._escapeSqlString = function (str) {
    return str.replace(/[\0\x08\x09\x1a\n\r"'\\\%]/g, function (char) {
        switch (char) {
            case "\0":
                return "\\0";
            case "\x08":
                return "\\b";
            case "\x09":
                return "\\t";
            case "\x1a":
                return "\\z";
            case "\n":
                return "\\n";
            case "\r":
                return "\\r";
			case "'":
				return "`";
            case "\"":
            case "\\":
            case "%":
                return "\\"+char; // prepends a backslash to backslash, percent,
                                  // and double/single quotes
        }
    });
}

module.exports = BetBot;
